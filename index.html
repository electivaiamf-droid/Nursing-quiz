<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Nursing VR Quiz</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { overflow:hidden; background:#000; font-family:Arial,sans-serif; touch-action:none; }
    
    #loading { 
      position:fixed; inset:0; background:#0a1a2f; color:#fff; 
      display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:9999; 
    }
    .loader { 
      border:12px solid #1e3a5f; border-top:12px solid #1caad9; 
      border-radius:50%; width:80px; height:80px; 
      animation:spin 1s linear infinite; margin:20px;
    }
    @keyframes spin { to { transform:rotate(360deg); } }
    
    #ui { 
      position:fixed; top:20px; left:50%; transform:translateX(-50%); 
      background:rgba(0,0,0,0.85); color:#fff; 
      padding:25px 40px; border-radius:20px; 
      text-align:center; z-index:100; display:none; 
      max-width:90%; box-shadow:0 10px 40px rgba(0,0,0,0.5);
    }
    #q { font-size:32px; font-weight:bold; margin-bottom:12px; }
    #s { font-size:24px; opacity:0.9; }
    
    #vr { 
      position:fixed; bottom:30px; left:50%; transform:translateX(-50%); 
      padding:18px 50px; font-size:24px; font-weight:bold;
      background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
      color:#fff; border:none; border-radius:50px; 
      cursor:pointer; z-index:100; display:none;
      box-shadow:0 8px 25px rgba(102,126,234,0.4);
      transition:transform 0.2s;
    }
    #vr:active { transform:translateX(-50%) scale(0.95); }
    
    #instructions {
      position:fixed; bottom:110px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.7); color:#fff; padding:12px 25px;
      border-radius:15px; font-size:16px; z-index:100; display:none;
      text-align:center; max-width:90%;
    }
    
    .reticle { 
      position:fixed; top:50%; left:50%; 
      width:40px; height:40px; 
      border:4px solid rgba(255,255,255,0.8); 
      border-radius:50%; 
      transform:translate(-50%,-50%); 
      pointer-events:none; z-index:99;
      box-shadow:0 0 20px rgba(255,255,255,0.3);
    }
    
    .prog { 
      position:fixed; top:50%; left:50%; 
      width:60px; height:60px; 
      border:6px solid transparent; 
      border-top:6px solid #00ffff; 
      border-radius:50%; 
      transform:translate(-50%,-50%); 
      display:none; 
      animation:spin 2s linear infinite; 
      z-index:98;
    }
    
    #fb { 
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); 
      font-size:60px; font-weight:bold; padding:40px 70px; 
      border-radius:25px; display:none; z-index:200; 
      text-align:center; color:#fff;
      box-shadow:0 15px 50px rgba(0,0,0,0.5);
    }
    #fb.correct { background:#00c853; }
    #fb.incorrect { background:#d32f2f; }
  </style>
</head>
<body>
  <div id="loading">
    <h1>Loading Hospital Room...</h1>
    <div class="loader"></div>
  </div>
  
  <div id="ui">
    <div id="q">Find the Adhesive Bandage</div>
    <div id="s">Score: 0/10</div>
  </div>
  
  <div id="instructions">
    Desktop: Move mouse to look â€¢ Mobile: Tilt device â€¢ Tap or look 2sec to select
  </div>
  
  <div class="reticle"></div>
  <div class="prog" id="prog"></div>
  <div id="fb"></div>
  <button id="vr">Enter VR Mode</button>

  <script>
    const BACKGROUND_FILE = "https://files.catbox.moe/reiuka.glb";

    const vocab = [
      {name:"Adhesive Bandage",     link:"https://files.catbox.moe/edy3gw.glb", color:0xF5DEB3, uses:"A small bandage to cover minor cuts or wounds"},
      {name:"Hand Sanitizer",       link:"https://files.catbox.moe/o997s6.glb", color:0x87CEEB, uses:"A liquid used to disinfect hands"},
      {name:"Antiseptic Solution",  link:"https://files.catbox.moe/1t002n.glb", color:0xDDA0DD, uses:"A liquid applied to wounds to prevent infection"},
      {name:"Cotton Balls",         link:"https://files.catbox.moe/eay3dl.glb", color:0xFFFFFF, uses:"Soft, absorbent material used for cleaning wounds"},
      {name:"Gauze",                link:"https://files.catbox.moe/vm9c7n.glb", color:0xFAFAFA, uses:"A type of thin, woven fabric used for dressing wounds"},
      {name:"Medical Gloves",       link:"https://files.catbox.moe/2tifp9.glb", color:0x98D8C8, uses:"Disposable gloves worn during medical procedures"},
      {name:"Saline Solution",      link:"https://files.catbox.moe/dgg8tw.glb", color:0xADD8E6, uses:"A mixture of salt and water, used for cleaning wounds"},
      {name:"Scissors",             link:"https://files.catbox.moe/bc4xkb.glb", color:0xC0C0C0, uses:"A tool for cutting"},
      {name:"Tweezers",             link:"https://files.catbox.moe/pf2i81.glb", color:0xB0B0B0, uses:"A tool for picking up small objects"},
      {name:"Thermometer",          link:"https://files.catbox.moe/0glqs3.glb", color:0xFF6B6B, uses:"A device used to measure body temperature"}
    ];

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1a2f);
    
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 0);
    
    const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:"high-performance"});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Game state
    let items = [], questions = [], q = 0, score = 0, busy = false;
    let gazed = null, gazeTime = 0;
    let isVR = false;
    
    // Create 3D reticle (for VR)
    const reticleGeometry = new THREE.RingGeometry(0.015, 0.02, 32);
    const reticleMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffffff, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.8
    });
    const reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
    reticle.position.set(0, 0, -1); // 1 meter in front of camera
    camera.add(reticle); // Attach to camera so it follows
    scene.add(camera); // Add camera to scene so reticle is visible
    reticle.visible = false; // Hidden by default (shown in VR)
    
    // Create 3D progress ring (for VR)
    const progressGeometry = new THREE.RingGeometry(0.02, 0.025, 32, 1, 0, Math.PI * 2);
    const progressMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x00ffff, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9
    });
    const progressRing = new THREE.Mesh(progressGeometry, progressMaterial);
    progressRing.position.set(0, 0, -1);
    camera.add(progressRing);
    progressRing.visible = false;
    
    // Create 3D text sprite for VR (question display)
    function createTextSprite(text, size = 0.8) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 2048;
      canvas.height = 512;
      
      context.fillStyle = 'rgba(0, 0, 0, 0.85)';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      context.font = 'bold 80px Arial';
      context.fillStyle = '#ffffff';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      
      // Word wrap
      const words = text.split(' ');
      let line = '';
      let y = 180;
      const maxWidth = 1900;
      const lineHeight = 100;
      
      for (let word of words) {
        const testLine = line + word + ' ';
        const metrics = context.measureText(testLine);
        if (metrics.width > maxWidth && line !== '') {
          context.fillText(line, canvas.width / 2, y);
          line = word + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      context.fillText(line, canvas.width / 2, y);
      
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(size * 4, size, 1);
      return sprite;
    }
    
    // Create VR question display
    let vrQuestionSprite = createTextSprite('Find the Adhesive Bandage');
    vrQuestionSprite.position.set(0, 0.65, -1.8); // Higher up, out of center view
    vrQuestionSprite.renderOrder = 999; // Render on top
    camera.add(vrQuestionSprite);
    vrQuestionSprite.visible = false;

    // Controls
    let targetRotationX = 0, targetRotationY = 0;
    let currentRotationX = 0, currentRotationY = 0;
    let lastTouchX = 0, lastTouchY = 0;

    // Desktop mouse controls (SMOOTH)
    document.addEventListener('mousemove', (e) => {
      if (isVR) return;
      // Convert mouse position to rotation (-180Â° to +180Â° horizontal, -60Â° to +60Â° vertical)
      targetRotationY = ((e.clientX / innerWidth) - 0.5) * Math.PI * 2;
      targetRotationX = -((e.clientY / innerHeight) - 0.5) * Math.PI * 0.6;
    });

    // Mobile touch controls (SWIPE)
    let isTouching = false;
    
    document.addEventListener('touchstart', (e) => {
      if (isVR) return;
      isTouching = true;
      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;
    });

    document.addEventListener('touchmove', (e) => {
      if (isVR || !isTouching) return;
      e.preventDefault();
      
      const deltaX = e.touches[0].clientX - lastTouchX;
      const deltaY = e.touches[0].clientY - lastTouchY;
      
      // Accumulate rotation (swipe to look around)
      targetRotationY += deltaX * 0.005;
      targetRotationX -= deltaY * 0.005;
      
      // Clamp vertical rotation
      targetRotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetRotationX));
      
      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;
    }, { passive: false });

    document.addEventListener('touchend', () => {
      isTouching = false;
    });

    // Device orientation (gyroscope) - OPTIONAL BACKUP
    let useGyro = false;
    window.addEventListener('deviceorientation', (e) => {
      if (!useGyro || isVR) return;
      if (e.beta !== null && e.gamma !== null) {
        targetRotationX = THREE.MathUtils.degToRad(e.beta - 90);
        targetRotationY = THREE.MathUtils.degToRad(e.gamma);
      }
    });

    // Load background
    const loader = new THREE.GLTFLoader();
    console.log('ðŸ¥ Attempting to load background:', BACKGROUND_FILE);
    
    loader.load(BACKGROUND_FILE, 
      gltf => {
        const hospital = gltf.scene;
        // Scale and position appropriately
        hospital.scale.set(1, 1, 1);
        hospital.position.set(0, 0, 0);
        scene.add(hospital);
        console.log('âœ“ Hospital loaded successfully!');
      },
      xhr => {
        if (xhr.lengthComputable) {
          const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
          console.log(`Loading hospital: ${percent}%`);
        }
      },
      err => {
        console.error('âŒ Background failed to load:', err);
        console.log('Creating fallback room...');
        
        // Better fallback room
        const floor = new THREE.Mesh(
          new THREE.CircleGeometry(20, 64),
          new THREE.MeshStandardMaterial({color:0xcccccc, roughness:0.8})
        );
        floor.rotation.x = -Math.PI/2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Add walls
        const wallGeometry = new THREE.CylinderGeometry(20, 20, 5, 32, 1, true);
        const wallMaterial = new THREE.MeshStandardMaterial({
          color:0xe8f4fc, 
          side:THREE.BackSide,
          roughness:0.9
        });
        const walls = new THREE.Mesh(wallGeometry, wallMaterial);
        walls.position.y = 2.5;
        scene.add(walls);
        
        console.log('âœ“ Fallback room created');
      }
    );

    // Generate questions
    function generateQuestions() {
  // Create a SHUFFLED copy of vocab so positions stay fixed, but questions are random
  const shuffled = [...vocab].sort(() => Math.random() - 0.5);

  questions = shuffled.map(item => {
    const useNamePrompt = Math.random() > 0.5;
    return {
      prompt: useNamePrompt ? `Find the ${item.name}` : `Find: ${item.uses}`,
      correctAnswer: item.name,
      item: item
    };
  });
}
      

    // Load items
    function loadItems() {
      const radius = 3; // Closer to player
      const angleStep = (Math.PI * 2) / vocab.length;
      
      // Load items in the SAME order as vocab (no shuffling here!)
      vocab.forEach((itemData, i) => {
        const angle = i * angleStep;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = 1.5; // Higher up, away from floor objects
        
        loader.load(itemData.link, 
          gltf => {
            const obj = gltf.scene;
            obj.position.set(x, y, z);
            
            // Auto-scale based on size
            const box = new THREE.Box3().setFromObject(obj);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const targetSize = 1.0; // Slightly smaller
            obj.scale.setScalar(targetSize / maxDim);
            
            obj.userData.name = itemData.name;
            obj.userData.uses = itemData.uses;
            obj.lookAt(camera.position);
            
            // Make items render on top of background
            obj.traverse((child) => {
              if (child.isMesh) {
                child.renderOrder = 100; // Render after background
                child.material.depthTest = true;
                child.material.depthWrite = true;
              }
            });
            
            scene.add(obj);
            items.push(obj);
            console.log(`âœ“ Loaded: ${itemData.name} at position ${i} (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`);
          },
          undefined,
          err => {
            console.warn(`Failed: ${itemData.name}`);
            // Fallback cube
            const cube = new THREE.Mesh(
              new THREE.BoxGeometry(0.5, 0.5, 0.5),
              new THREE.MeshStandardMaterial({
                color: itemData.color,
                emissive: itemData.color,
                emissiveIntensity: 0.3
              })
            );
            cube.position.set(x, y, z);
            cube.userData.name = itemData.name;
            cube.userData.uses = itemData.uses;
            cube.renderOrder = 100;
            scene.add(cube);
            items.push(cube);
          }
        );
      });
    }

    // Update question UI
    function updateQuestion() {
      if (q >= questions.length) {
        showCompletion();
        return;
      }
      const questionText = questions[q].prompt;
      const scoreText = `Score: ${score}/${questions.length}`;
      
      // Update HTML UI
      document.getElementById('q').textContent = questionText;
      document.getElementById('s').textContent = scoreText;
      
      // Update VR 3D text
      if (vrQuestionSprite) {
        camera.remove(vrQuestionSprite);
        vrQuestionSprite.geometry.dispose();
        vrQuestionSprite.material.map.dispose();
        vrQuestionSprite.material.dispose();
      }
      vrQuestionSprite = createTextSprite(`${questionText}\n${scoreText}`, 0.6); // Smaller size
      vrQuestionSprite.position.set(0, 0.65, -1.8); // Top of view, out of way
      vrQuestionSprite.renderOrder = 999; // Always render on top
      camera.add(vrQuestionSprite);
      vrQuestionSprite.visible = isVR;
      
      console.log(`Question updated: ${questionText} | VR text visible: ${isVR}`);
    }

    // Answer handler
    function answer(obj) {
      if (busy) return;
      busy = true;
      
      const correct = obj.userData.name === questions[q].correctAnswer;
      if (correct) score++;

      const fb = document.getElementById('fb');
      fb.className = correct ? 'correct' : 'incorrect';
      fb.textContent = correct ? 'âœ“ Correct!' : 'âœ— Incorrect';
      fb.style.display = 'block';
      
      // Text-to-speech
      if (correct) {
        speak(`Correct! ${obj.userData.name}. ${obj.userData.uses}`);
      } else {
        speak(`Incorrect. That is ${obj.userData.name}. The correct answer was ${questions[q].correctAnswer}`);
      }
      
      setTimeout(() => {
        fb.style.display = 'none';
        q++;
        updateQuestion();
        busy = false;
      }, 3000);
    }

    function showCompletion() {
      const fb = document.getElementById('fb');
      fb.className = 'correct';
      fb.textContent = `ðŸŽ‰ Quiz Complete!\nScore: ${score}/${questions.length}`;
      fb.style.display = 'block';
      speak(`Quiz complete! You scored ${score} out of ${questions.length}`);
      
      setTimeout(() => {
        if (confirm(`You scored ${score}/${questions.length}!\n\nPlay again?`)) {
          location.reload();
        }
      }, 3000);
    }

    function speak(text) {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      }
    }

    // Animation loop
    function animate() {
      // Only apply desktop/mobile controls when NOT in VR
      if (!isVR) {
        // Smooth camera rotation (lerp for smoothness)
        const smoothFactor = 0.08; // Lower = smoother
        currentRotationY += (targetRotationY - currentRotationY) * smoothFactor;
        currentRotationX += (targetRotationX - currentRotationX) * smoothFactor;
        
        camera.rotation.order = 'YXZ';
        camera.rotation.y = currentRotationY;
        camera.rotation.x = currentRotationX;
      }
      // In VR, camera rotation is handled automatically by the headset

      // Rotate items
      items.forEach(obj => obj.rotation.y += 0.005);

      // Gaze detection (works in both desktop and VR)
      if (!busy && items.length > 0) {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const hits = raycaster.intersectObjects(items, true);
        
        if (hits.length) {
          let obj = hits[0].object;
          while (obj && !obj.userData?.name) obj = obj.parent;
          
          if (obj?.userData?.name) {
            if (gazed !== obj) {
              gazed = obj;
              gazeTime = performance.now();
              // Show progress indicator (HTML for desktop, 3D for VR)
              if (isVR) {
                progressRing.visible = true;
              } else {
                document.getElementById('prog').style.display = 'block';
              }
            } else {
              const elapsed = performance.now() - gazeTime;
              
              // Animate progress ring in VR
              if (isVR && progressRing.visible) {
                const progress = Math.min(elapsed / 2000, 1);
                progressRing.geometry.dispose();
                progressRing.geometry = new THREE.RingGeometry(
                  0.02, 0.025, 32, 1, 0, Math.PI * 2 * progress
                );
              }
              
              if (elapsed > 2000) {
                // Selection complete!
                if (isVR) {
                  progressRing.visible = false;
                } else {
                  document.getElementById('prog').style.display = 'none';
                }
                answer(obj);
                gazed = null;
              }
            }
          }
        } else {
          gazed = null;
          if (isVR) {
            progressRing.visible = false;
          } else {
            document.getElementById('prog').style.display = 'none';
          }
        }
      }
      
      renderer.render(scene, camera);
    }

    // Click/tap to select
    document.addEventListener('click', () => {
      if (busy || items.length === 0) return;
      
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const hits = raycaster.intersectObjects(items, true);
      
      if (hits.length) {
        let obj = hits[0].object;
        while (obj && !obj.userData?.name) obj = obj.parent;
        if (obj?.userData?.name) answer(obj);
      }
    });

    // VR button
    document.getElementById('vr').onclick = () => {
      if ('xr' in navigator) {
        navigator.xr.requestSession('immersive-vr', {
          requiredFeatures: ['local-floor'],
          optionalFeatures: ['bounded-floor', 'hand-tracking']
        }).then(session => {
          renderer.xr.setSession(session);
          isVR = true;
          console.log('âœ“ VR session started');
        }).catch(err => {
          console.error('VR error:', err);
          alert('VR not available.\n\nMake sure:\n- You\'re on HTTPS\n- VR device connected\n- Using Chrome/Edge/Oculus Browser');
        });
      } else {
        alert('WebXR not supported in this browser.');
      }
    };

    // VR session management
    renderer.xr.addEventListener('sessionstart', () => {
      isVR = true;
      // Show 3D reticle and question text in VR
      reticle.visible = true;
      vrQuestionSprite.visible = true;
      // Hide HTML UI elements
      document.querySelector('.reticle').style.display = 'none';
      document.querySelector('.prog').style.display = 'none';
      document.getElementById('ui').style.display = 'none'; // Hide HTML UI in VR
      document.getElementById('instructions').style.display = 'none';
      console.log('âœ“ VR mode active - 3D UI enabled');
    });
    
    renderer.xr.addEventListener('sessionend', () => {
      isVR = false;
      // Hide 3D elements, show HTML UI
      reticle.visible = false;
      progressRing.visible = false;
      vrQuestionSprite.visible = false;
      document.querySelector('.reticle').style.display = 'block';
      document.getElementById('ui').style.display = 'block';
      document.getElementById('instructions').style.display = 'block';
      console.log('âœ“ VR mode ended');
    });

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Start experience
    setTimeout(() => {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('ui').style.display = 'block';
      document.getElementById('vr').style.display = 'block';
      document.getElementById('instructions').style.display = 'block';
      
      generateQuestions();
      loadItems();
      updateQuestion();
      renderer.setAnimationLoop(animate);
    }, 1500);
  </script>
</body>
</html>


