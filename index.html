<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Nursing VR Quiz</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { overflow:hidden; background:#000; font-family:Arial,sans-serif; touch-action:none; }
    
    #loading { 
      position:fixed; inset:0; background:#0a1a2f; color:#fff; 
      display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:9999; 
    }
    .loader { 
      border:12px solid #1e3a5f; border-top:12px solid #1caad9; 
      border-radius:50%; width:80px; height:80px; 
      animation:spin 1s linear infinite; margin:20px;
    }
    @keyframes spin { to { transform:rotate(360deg); } }
    
    #ui { 
      position:fixed; top:20px; left:50%; transform:translateX(-50%); 
      background:rgba(0,0,0,0.85); color:#fff; 
      padding:25px 40px; border-radius:20px; 
      text-align:center; z-index:100; display:none; 
      max-width:90%; box-shadow:0 10px 40px rgba(0,0,0,0.5);
    }
    #q { font-size:32px; font-weight:bold; margin-bottom:12px; }
    #s { font-size:24px; opacity:0.9; }
    
    #vr { 
      position:fixed; bottom:30px; left:50%; transform:translateX(-50%); 
      padding:18px 50px; font-size:24px; font-weight:bold;
      background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
      color:#fff; border:none; border-radius:50px; 
      cursor:pointer; z-index:100; display:none;
      box-shadow:0 8px 25px rgba(102,126,234,0.4);
      transition:transform 0.2s;
    }
    #vr:active { transform:translateX(-50%) scale(0.95); }
    
    #instructions {
      position:fixed; bottom:110px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.7); color:#fff; padding:12px 25px;
      border-radius:15px; font-size:16px; z-index:100; display:none;
      text-align:center; max-width:90%;
    }
    
    .reticle { 
      position:fixed; top:50%; left:50%; 
      width:40px; height:40px; 
      border:4px solid rgba(255,255,255,0.8); 
      border-radius:50%; 
      transform:translate(-50%,-50%); 
      pointer-events:none; z-index:99;
      box-shadow:0 0 20px rgba(255,255,255,0.3);
    }
    
    .prog { 
      position:fixed; top:50%; left:50%; 
      width:60px; height:60px; 
      border:6px solid transparent; 
      border-top:6px solid #00ffff; 
      border-radius:50%; 
      transform:translate(-50%,-50%); 
      display:none; 
      animation:spin 2s linear infinite; 
      z-index:98;
    }
    
    #fb { 
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); 
      font-size:60px; font-weight:bold; padding:40px 70px; 
      border-radius:25px; display:none; z-index:200; 
      text-align:center; color:#fff;
      box-shadow:0 15px 50px rgba(0,0,0,0.5);
    }
    #fb.correct { background:#00c853; }
    #fb.incorrect { background:#d32f2f; }
  </style>
</head>
<body>
  <div id="loading">
    <h1>Loading Hospital Room...</h1>
    <div class="loader"></div>
  </div>
  
  <div id="ui">
    <div id="q">Find the Adhesive Bandage</div>
    <div id="s">Score: 0/10</div>
  </div>
  
  <div id="instructions">
    Desktop: Move mouse to look â€¢ Mobile: Tilt device â€¢ Tap or look 2sec to select
  </div>
  
  <div class="reticle"></div>
  <div class="prog" id="prog"></div>
  <div id="fb"></div>
  <button id="vr">Enter VR Mode</button>

  <script>
    const BACKGROUND_FILE = "https://files.catbox.moe/reiuka.glb";

    const vocab = [
      {name:"Adhesive Bandage",     link:"https://files.catbox.moe/edy3gw.glb", color:0xF5DEB3, uses:"A small bandage to cover minor cuts or wounds"},
      {name:"Hand Sanitizer",       link:"https://files.catbox.moe/o997s6.glb", color:0x87CEEB, uses:"A liquid used to disinfect hands"},
      {name:"Antiseptic Solution",  link:"https://files.catbox.moe/1t002n.glb", color:0xDDA0DD, uses:"A liquid applied to wounds to prevent infection"},
      {name:"Cotton Balls",         link:"https://files.catbox.moe/eay3dl.glb", color:0xFFFFFF, uses:"Soft, absorbent material used for cleaning wounds"},
      {name:"Gauze",                link:"https://files.catbox.moe/vm9c7n.glb", color:0xFAFAFA, uses:"A type of thin, woven fabric used for dressing wounds"},
      {name:"Medical Gloves",       link:"https://files.catbox.moe/2tifp9.glb", color:0x98D8C8, uses:"Disposable gloves worn during medical procedures"},
      {name:"Saline Solution",      link:"https://files.catbox.moe/dgg8tw.glb", color:0xADD8E6, uses:"A mixture of salt and water, used for cleaning wounds"},
      {name:"Scissors",             link:"https://files.catbox.moe/bc4xkb.glb", color:0xC0C0C0, uses:"A tool for cutting"},
      {name:"Tweezers",             link:"https://files.catbox.moe/pf2i81.glb", color:0xB0B0B0, uses:"A tool for picking up small objects"},
      {name:"Thermometer",          link:"https://files.catbox.moe/0glqs3.glb", color:0xFF6B6B, uses:"A device used to measure body temperature"}
    ];

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1a2f);
    
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 0);
    
    const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:"high-performance"});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Game state
    let items = [], questions = [], q = 0, score = 0, busy = false;
    let gazed = null, gazeTime = 0;
    let isVR = false;

    // Controls
    let targetRotationX = 0, targetRotationY = 0;
    let currentRotationX = 0, currentRotationY = 0;
    let lastTouchX = 0, lastTouchY = 0;

    // Desktop mouse controls (SMOOTH)
    document.addEventListener('mousemove', (e) => {
      if (isVR) return;
      // Convert mouse position to rotation (-180Â° to +180Â° horizontal, -60Â° to +60Â° vertical)
      targetRotationY = ((e.clientX / innerWidth) - 0.5) * Math.PI * 2;
      targetRotationX = -((e.clientY / innerHeight) - 0.5) * Math.PI * 0.6;
    });

    // Mobile touch controls (SWIPE)
    let isTouching = false;
    
    document.addEventListener('touchstart', (e) => {
      if (isVR) return;
      isTouching = true;
      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;
    });

    document.addEventListener('touchmove', (e) => {
      if (isVR || !isTouching) return;
      e.preventDefault();
      
      const deltaX = e.touches[0].clientX - lastTouchX;
      const deltaY = e.touches[0].clientY - lastTouchY;
      
      // Accumulate rotation (swipe to look around)
      targetRotationY += deltaX * 0.005;
      targetRotationX -= deltaY * 0.005;
      
      // Clamp vertical rotation
      targetRotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetRotationX));
      
      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;
    }, { passive: false });

    document.addEventListener('touchend', () => {
      isTouching = false;
    });

    // Device orientation (gyroscope) - OPTIONAL BACKUP
    let useGyro = false;
    window.addEventListener('deviceorientation', (e) => {
      if (!useGyro || isVR) return;
      if (e.beta !== null && e.gamma !== null) {
        targetRotationX = THREE.MathUtils.degToRad(e.beta - 90);
        targetRotationY = THREE.MathUtils.degToRad(e.gamma);
      }
    });

    // Load background
    const loader = new THREE.GLTFLoader();
    loader.load(BACKGROUND_FILE, 
      gltf => {
        scene.add(gltf.scene);
        console.log('âœ“ Hospital loaded');
      },
      undefined,
      err => {
        console.warn('Background failed, using fallback');
        const floor = new THREE.Mesh(
          new THREE.CircleGeometry(20, 64),
          new THREE.MeshStandardMaterial({color:0xaaaaaa})
        );
        floor.rotation.x = -Math.PI/2;
        scene.add(floor);
      }
    );

    // Generate questions
    function generateQuestions() {
      const shuffled = [...vocab].sort(() => Math.random() - 0.5);
      questions = shuffled.map(item => ({
        prompt: Math.random() > 0.5 ? `Find the ${item.name}` : `Find: ${item.uses}`,
        correctAnswer: item.name,
        item: item
      }));
    }

    // Load items
    function loadItems() {
      const radius = 4;
      const angleStep = (Math.PI * 2) / vocab.length;
      
      questions.forEach((question, i) => {
        const angle = i * angleStep;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = 1.2 + (Math.random() * 0.3);
        
        const itemData = question.item;
        
        loader.load(itemData.link, 
          gltf => {
            const obj = gltf.scene;
            obj.position.set(x, y, z);
            
            // Auto-scale based on size
            const box = new THREE.Box3().setFromObject(obj);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const targetSize = 0.6;
            obj.scale.setScalar(targetSize / maxDim);
            
            obj.userData.name = itemData.name;
            obj.userData.uses = itemData.uses;
            obj.lookAt(camera.position);
            
            scene.add(obj);
            items.push(obj);
            console.log(`âœ“ Loaded: ${itemData.name}`);
          },
          undefined,
          err => {
            console.warn(`Failed: ${itemData.name}`);
            // Fallback cube
            const cube = new THREE.Mesh(
              new THREE.BoxGeometry(0.5, 0.5, 0.5),
              new THREE.MeshStandardMaterial({
                color: itemData.color,
                emissive: itemData.color,
                emissiveIntensity: 0.3
              })
            );
            cube.position.set(x, y, z);
            cube.userData.name = itemData.name;
            cube.userData.uses = itemData.uses;
            scene.add(cube);
            items.push(cube);
          }
        );
      });
    }

    // Update question UI
    function updateQuestion() {
      if (q >= questions.length) {
        showCompletion();
        return;
      }
      document.getElementById('q').textContent = questions[q].prompt;
      document.getElementById('s').textContent = `Score: ${score}/${questions.length}`;
    }

    // Answer handler
    function answer(obj) {
      if (busy) return;
      busy = true;
      
      const correct = obj.userData.name === questions[q].correctAnswer;
      if (correct) score++;

      const fb = document.getElementById('fb');
      fb.className = correct ? 'correct' : 'incorrect';
      fb.textContent = correct ? 'âœ“ Correct!' : 'âœ— Incorrect';
      fb.style.display = 'block';
      
      // Text-to-speech
      if (correct) {
        speak(`Correct! ${obj.userData.name}. ${obj.userData.uses}`);
      } else {
        speak(`Incorrect. That is ${obj.userData.name}. The correct answer was ${questions[q].correctAnswer}`);
      }
      
      setTimeout(() => {
        fb.style.display = 'none';
        q++;
        updateQuestion();
        busy = false;
      }, 3000);
    }

    function showCompletion() {
      const fb = document.getElementById('fb');
      fb.className = 'correct';
      fb.textContent = `ðŸŽ‰ Quiz Complete!\nScore: ${score}/${questions.length}`;
      fb.style.display = 'block';
      speak(`Quiz complete! You scored ${score} out of ${questions.length}`);
      
      setTimeout(() => {
        if (confirm(`You scored ${score}/${questions.length}!\n\nPlay again?`)) {
          location.reload();
        }
      }, 3000);
    }

    function speak(text) {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      }
    }

    // Animation loop
    function animate() {
      // Smooth camera rotation (lerp for smoothness)
      const smoothFactor = 0.08; // Lower = smoother
      currentRotationY += (targetRotationY - currentRotationY) * smoothFactor;
      currentRotationX += (targetRotationX - currentRotationX) * smoothFactor;
      
      camera.rotation.order = 'YXZ';
      camera.rotation.y = currentRotationY;
      camera.rotation.x = currentRotationX;

      // Rotate items
      items.forEach(obj => obj.rotation.y += 0.005);

      // Gaze detection
      if (!busy && items.length > 0) {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const hits = raycaster.intersectObjects(items, true);
        
        if (hits.length) {
          let obj = hits[0].object;
          while (obj && !obj.userData?.name) obj = obj.parent;
          
          if (obj?.userData?.name) {
            if (gazed !== obj) {
              gazed = obj;
              gazeTime = performance.now();
              document.getElementById('prog').style.display = 'block';
            } else if (performance.now() - gazeTime > 2000) {
              document.getElementById('prog').style.display = 'none';
              answer(obj);
              gazed = null;
            }
          }
        } else {
          gazed = null;
          document.getElementById('prog').style.display = 'none';
        }
      }
      
      renderer.render(scene, camera);
    }

    // Click/tap to select
    document.addEventListener('click', () => {
      if (busy || items.length === 0) return;
      
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const hits = raycaster.intersectObjects(items, true);
      
      if (hits.length) {
        let obj = hits[0].object;
        while (obj && !obj.userData?.name) obj = obj.parent;
        if (obj?.userData?.name) answer(obj);
      }
    });

    // VR button
    document.getElementById('vr').onclick = () => {
      if ('xr' in navigator) {
        navigator.xr.requestSession('immersive-vr', {
          optionalFeatures: ['local-floor', 'bounded-floor']
        }).then(session => {
          renderer.xr.setSession(session);
          isVR = true;
        }).catch(err => {
          alert('VR not available.\n\nMake sure:\n- You\'re on HTTPS\n- VR device connected\n- Using Chrome/Edge/Oculus Browser');
        });
      } else {
        alert('WebXR not supported in this browser.');
      }
    };

    // VR session management
    renderer.xr.addEventListener('sessionstart', () => {
      isVR = true;
      console.log('VR session started');
    });
    
    renderer.xr.addEventListener('sessionend', () => {
      isVR = false;
      console.log('VR session ended');
    });

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Start experience
    setTimeout(() => {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('ui').style.display = 'block';
      document.getElementById('vr').style.display = 'block';
      document.getElementById('instructions').style.display = 'block';
      
      generateQuestions();
      loadItems();
      updateQuestion();
      renderer.setAnimationLoop(animate);
    }, 1500);
  </script>
</body>
</html>

